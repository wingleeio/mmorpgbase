// @generated by protobuf-ts 2.1.0
// @generated from protobuf file "schema.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message Movement
 */
export interface Movement {
    /**
     * @generated from protobuf field: bool up = 1;
     */
    up: boolean;
    /**
     * @generated from protobuf field: bool down = 2;
     */
    down: boolean;
    /**
     * @generated from protobuf field: bool left = 3;
     */
    left: boolean;
    /**
     * @generated from protobuf field: bool right = 4;
     */
    right: boolean;
}
/**
 * @generated from protobuf message MovementInput
 */
export interface MovementInput {
    /**
     * @generated from protobuf field: Direction direction = 1;
     */
    direction: Direction;
    /**
     * @generated from protobuf field: bool isMoving = 2;
     */
    isMoving: boolean;
}
/**
 * @generated from protobuf message Player
 */
export interface Player {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: double x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: double y = 4;
     */
    y: number;
    /**
     * @generated from protobuf field: int32 sprite = 5;
     */
    sprite: number;
    /**
     * @generated from protobuf field: Direction direction = 6;
     */
    direction: Direction;
    /**
     * @generated from protobuf field: Movement movement = 7;
     */
    movement?: Movement;
    /**
     * @generated from protobuf field: double speed = 8;
     */
    speed: number;
}
/**
 * @generated from protobuf message PlayersState
 */
export interface PlayersState {
    /**
     * @generated from protobuf field: map<int32, Player> players = 1;
     */
    players: {
        [key: number]: Player;
    };
}
/**
 * @generated from protobuf message ClientPacket
 */
export interface ClientPacket {
    /**
     * @generated from protobuf field: int64 time = 1;
     */
    time: bigint;
    /**
     * @generated from protobuf field: ClientPacketType type = 2;
     */
    type: ClientPacketType;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "movementInput";
        /**
         * @generated from protobuf field: MovementInput movementInput = 3;
         */
        movementInput: MovementInput;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message ServerPacket
 */
export interface ServerPacket {
    /**
     * @generated from protobuf field: optional int64 time = 1;
     */
    time?: bigint;
    /**
     * @generated from protobuf field: ServerPacketType type = 2;
     */
    type: ServerPacketType;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "players";
        /**
         * @generated from protobuf field: PlayersState players = 3;
         */
        players: PlayersState;
    } | {
        oneofKind: "id";
        /**
         * @generated from protobuf field: int32 id = 4;
         */
        id: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum Direction
 */
export enum Direction {
    /**
     * @generated from protobuf enum value: UP = 0;
     */
    UP = 0,
    /**
     * @generated from protobuf enum value: DOWN = 1;
     */
    DOWN = 1,
    /**
     * @generated from protobuf enum value: LEFT = 2;
     */
    LEFT = 2,
    /**
     * @generated from protobuf enum value: RIGHT = 3;
     */
    RIGHT = 3
}
/**
 * @generated from protobuf enum ClientPacketType
 */
export enum ClientPacketType {
    /**
     * @generated from protobuf enum value: MOVEMENT_INPUT = 0;
     */
    MOVEMENT_INPUT = 0
}
/**
 * @generated from protobuf enum ServerPacketType
 */
export enum ServerPacketType {
    /**
     * @generated from protobuf enum value: PLAYERS = 0;
     */
    PLAYERS = 0,
    /**
     * @generated from protobuf enum value: PLAYER_DISCONNECTED = 1;
     */
    PLAYER_DISCONNECTED = 1,
    /**
     * @generated from protobuf enum value: INITIALIZE = 2;
     */
    INITIALIZE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Movement$Type extends MessageType<Movement> {
    constructor() {
        super("Movement", [
            { no: 1, name: "up", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "down", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "left", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "right", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Movement>): Movement {
        const message = { up: false, down: false, left: false, right: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Movement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Movement): Movement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool up */ 1:
                    message.up = reader.bool();
                    break;
                case /* bool down */ 2:
                    message.down = reader.bool();
                    break;
                case /* bool left */ 3:
                    message.left = reader.bool();
                    break;
                case /* bool right */ 4:
                    message.right = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Movement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool up = 1; */
        if (message.up !== false)
            writer.tag(1, WireType.Varint).bool(message.up);
        /* bool down = 2; */
        if (message.down !== false)
            writer.tag(2, WireType.Varint).bool(message.down);
        /* bool left = 3; */
        if (message.left !== false)
            writer.tag(3, WireType.Varint).bool(message.left);
        /* bool right = 4; */
        if (message.right !== false)
            writer.tag(4, WireType.Varint).bool(message.right);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Movement
 */
export const Movement = new Movement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MovementInput$Type extends MessageType<MovementInput> {
    constructor() {
        super("MovementInput", [
            { no: 1, name: "direction", kind: "enum", T: () => ["Direction", Direction] },
            { no: 2, name: "isMoving", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MovementInput>): MovementInput {
        const message = { direction: 0, isMoving: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MovementInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MovementInput): MovementInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Direction direction */ 1:
                    message.direction = reader.int32();
                    break;
                case /* bool isMoving */ 2:
                    message.isMoving = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MovementInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Direction direction = 1; */
        if (message.direction !== 0)
            writer.tag(1, WireType.Varint).int32(message.direction);
        /* bool isMoving = 2; */
        if (message.isMoving !== false)
            writer.tag(2, WireType.Varint).bool(message.isMoving);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MovementInput
 */
export const MovementInput = new MovementInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player$Type extends MessageType<Player> {
    constructor() {
        super("Player", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "sprite", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "direction", kind: "enum", T: () => ["Direction", Direction] },
            { no: 7, name: "movement", kind: "message", T: () => Movement },
            { no: 8, name: "speed", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Player>): Player {
        const message = { id: 0, name: "", x: 0, y: 0, sprite: 0, direction: 0, speed: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Player>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Player): Player {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* double x */ 3:
                    message.x = reader.double();
                    break;
                case /* double y */ 4:
                    message.y = reader.double();
                    break;
                case /* int32 sprite */ 5:
                    message.sprite = reader.int32();
                    break;
                case /* Direction direction */ 6:
                    message.direction = reader.int32();
                    break;
                case /* Movement movement */ 7:
                    message.movement = Movement.internalBinaryRead(reader, reader.uint32(), options, message.movement);
                    break;
                case /* double speed */ 8:
                    message.speed = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* double x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit64).double(message.x);
        /* double y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Bit64).double(message.y);
        /* int32 sprite = 5; */
        if (message.sprite !== 0)
            writer.tag(5, WireType.Varint).int32(message.sprite);
        /* Direction direction = 6; */
        if (message.direction !== 0)
            writer.tag(6, WireType.Varint).int32(message.direction);
        /* Movement movement = 7; */
        if (message.movement)
            Movement.internalBinaryWrite(message.movement, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* double speed = 8; */
        if (message.speed !== 0)
            writer.tag(8, WireType.Bit64).double(message.speed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player
 */
export const Player = new Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayersState$Type extends MessageType<PlayersState> {
    constructor() {
        super("PlayersState", [
            { no: 1, name: "players", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => Player } }
        ]);
    }
    create(value?: PartialMessage<PlayersState>): PlayersState {
        const message = { players: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayersState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayersState): PlayersState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, Player> players */ 1:
                    this.binaryReadMap1(message.players, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: PlayersState["players"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PlayersState["players"] | undefined, val: PlayersState["players"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = Player.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field PlayersState.players");
            }
        }
        map[key ?? 0] = val ?? Player.create();
    }
    internalBinaryWrite(message: PlayersState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, Player> players = 1; */
        for (let k of Object.keys(message.players)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            Player.internalBinaryWrite(message.players[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayersState
 */
export const PlayersState = new PlayersState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientPacket$Type extends MessageType<ClientPacket> {
    constructor() {
        super("ClientPacket", [
            { no: 1, name: "time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["ClientPacketType", ClientPacketType] },
            { no: 3, name: "movementInput", kind: "message", oneof: "data", T: () => MovementInput }
        ]);
    }
    create(value?: PartialMessage<ClientPacket>): ClientPacket {
        const message = { time: 0n, type: 0, data: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClientPacket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientPacket): ClientPacket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 time */ 1:
                    message.time = reader.int64().toBigInt();
                    break;
                case /* ClientPacketType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* MovementInput movementInput */ 3:
                    message.data = {
                        oneofKind: "movementInput",
                        movementInput: MovementInput.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).movementInput)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientPacket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 time = 1; */
        if (message.time !== 0n)
            writer.tag(1, WireType.Varint).int64(message.time);
        /* ClientPacketType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* MovementInput movementInput = 3; */
        if (message.data.oneofKind === "movementInput")
            MovementInput.internalBinaryWrite(message.data.movementInput, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClientPacket
 */
export const ClientPacket = new ClientPacket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerPacket$Type extends MessageType<ServerPacket> {
    constructor() {
        super("ServerPacket", [
            { no: 1, name: "time", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["ServerPacketType", ServerPacketType] },
            { no: 3, name: "players", kind: "message", oneof: "data", T: () => PlayersState },
            { no: 4, name: "id", kind: "scalar", oneof: "data", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ServerPacket>): ServerPacket {
        const message = { type: 0, data: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerPacket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerPacket): ServerPacket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 time */ 1:
                    message.time = reader.int64().toBigInt();
                    break;
                case /* ServerPacketType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* PlayersState players */ 3:
                    message.data = {
                        oneofKind: "players",
                        players: PlayersState.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).players)
                    };
                    break;
                case /* int32 id */ 4:
                    message.data = {
                        oneofKind: "id",
                        id: reader.int32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerPacket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 time = 1; */
        if (message.time !== undefined)
            writer.tag(1, WireType.Varint).int64(message.time);
        /* ServerPacketType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* PlayersState players = 3; */
        if (message.data.oneofKind === "players")
            PlayersState.internalBinaryWrite(message.data.players, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int32 id = 4; */
        if (message.data.oneofKind === "id")
            writer.tag(4, WireType.Varint).int32(message.data.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServerPacket
 */
export const ServerPacket = new ServerPacket$Type();
