"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionResolver = exports.makeInternalOptions = exports.ServerStyle = exports.ClientStyle = exports.readOurServiceOptions = exports.readOurFileOptions = void 0;
/**
 * Custom file options interpreted by @protobuf-ts/plugin
 */
const rt = require("@protobuf-ts/runtime");
const plugin_framework_1 = require("@protobuf-ts/plugin-framework");
/**
 * Read the custom file options declared in protobuf-ts.proto
 */
function readOurFileOptions(file) {
    return read(file.options, emptyFileOptions, OurFileOptions);
}
exports.readOurFileOptions = readOurFileOptions;
/**
 * Read the custom service options declared in protobuf-ts.proto
 */
function readOurServiceOptions(service) {
    return read(service.options, emptyServiceOptions, OurServiceOptions);
}
exports.readOurServiceOptions = readOurServiceOptions;
function read(options, defaults, type) {
    if (!options) {
        return defaults;
    }
    let unknownFields = rt.UnknownFieldHandler.list(options);
    if (!unknownFields.length) {
        return defaults;
    }
    // concat all unknown field data
    let unknownWriter = new rt.BinaryWriter();
    for (let { no, wireType, data } of unknownFields)
        unknownWriter.tag(no, wireType).raw(data);
    let unknownBytes = unknownWriter.finish();
    return type.fromBinary(unknownBytes, { readUnknownField: false });
}
const OurFileOptions = new rt.MessageType("$synthetic.OurFileOptions", [
    {
        no: 777701,
        name: "ts.exclude_options", localName: "ts.exclude_options", jsonName: "ts.exclude_options",
        kind: "scalar",
        T: rt.ScalarType.STRING,
        repeat: rt.RepeatType.PACKED
    }
]);
const OurServiceOptions = new rt.MessageType("$synthetic.OurServiceOptions", [
    {
        no: 777701,
        name: "ts.client", localName: "ts.client", jsonName: "ts.client",
        kind: "enum",
        T: () => ["ts.ClientStyle", ClientStyle],
        repeat: rt.RepeatType.UNPACKED,
    },
    {
        no: 777702,
        name: "ts.server", localName: "ts.server", jsonName: "ts.server",
        kind: "enum",
        T: () => ["ts.ServerStyle", ServerStyle],
        repeat: rt.RepeatType.UNPACKED,
    }
]);
/**
 * The available client styles from @protobuf-ts/plugin
 * The extensions are declared in protobuf-ts.proto
 */
var ClientStyle;
(function (ClientStyle) {
    /**
     * Do not emit a client for this service.
     */
    ClientStyle[ClientStyle["NO_CLIENT"] = 0] = "NO_CLIENT";
    /**
     * Use the call implementations of @protobuf-ts/runtime-rpc.
     * This is the default behaviour.
     */
    ClientStyle[ClientStyle["GENERIC_CLIENT"] = 1] = "GENERIC_CLIENT";
    /**
     * Generate a client using @grpc/grpc-js (major version 1).
     */
    ClientStyle[ClientStyle["GRPC1_CLIENT"] = 4] = "GRPC1_CLIENT";
})(ClientStyle = exports.ClientStyle || (exports.ClientStyle = {}));
/**
 * The available server styles from @protobuf-ts/plugin
 * The extensions are declared in protobuf-ts.proto
 */
var ServerStyle;
(function (ServerStyle) {
    /**
     * Do not emit a server for this service.
     * This is the default behaviour.
     */
    ServerStyle[ServerStyle["NO_SERVER"] = 0] = "NO_SERVER";
    /**
     * Generate a generic server interface.
     * Adapters be used to serve the service, for example @protobuf-ts/grpc-backend
     * for gRPC.
     */
    ServerStyle[ServerStyle["GENERIC_SERVER"] = 1] = "GENERIC_SERVER";
    /**
     * Generate a server for @grpc/grpc-js (major version 1).
     */
    ServerStyle[ServerStyle["GRPC1_SERVER"] = 2] = "GRPC1_SERVER";
})(ServerStyle = exports.ServerStyle || (exports.ServerStyle = {}));
const emptyFileOptions = OurFileOptions.create();
const emptyServiceOptions = OurServiceOptions.create();
function makeInternalOptions(options) {
    let o = options, i = defaultOptions;
    if (!o)
        return i;
    for (let k of Object.keys(defaultOptions)) {
        if (o[k] === undefined) {
            o[k] = i[k];
        }
    }
    return o;
}
exports.makeInternalOptions = makeInternalOptions;
const defaultOptions = {
    normalLongType: rt.LongType.BIGINT,
    emitAngularAnnotations: false,
    synthesizeEnumZeroValue: 'UNSPECIFIED$',
    oneofKindDiscriminator: 'oneofKind',
    runtimeAngularImportPath: '@protobuf-ts/runtime-angular',
    runtimeRpcImportPath: '@protobuf-ts/runtime-rpc',
    angularCoreImportPath: '@angular/core',
    runtimeImportPath: '@protobuf-ts/runtime',
    forceExcludeAllOptions: false,
    keepEnumPrefix: false,
};
class OptionResolver {
    constructor(interpreter, stringFormat, params) {
        this.interpreter = interpreter;
        this.stringFormat = stringFormat;
        this.params = params;
    }
    getOptimizeMode(file) {
        var _a;
        if (this.params.force_optimize_code_size)
            return plugin_framework_1.FileOptions_OptimizeMode.CODE_SIZE;
        if (this.params.force_optimize_speed)
            return plugin_framework_1.FileOptions_OptimizeMode.SPEED;
        if ((_a = file.options) === null || _a === void 0 ? void 0 : _a.optimizeFor)
            return file.options.optimizeFor;
        if (this.params.optimize_code_size)
            return plugin_framework_1.FileOptions_OptimizeMode.CODE_SIZE;
        return plugin_framework_1.FileOptions_OptimizeMode.SPEED;
    }
    getClientStyles(descriptor) {
        const opt = this.interpreter.readOurServiceOptions(descriptor)["ts.client"];
        // always check service options valid
        if (opt.includes(ClientStyle.NO_CLIENT) && opt.some(s => s !== ClientStyle.NO_CLIENT)) {
            let err = new Error(`You provided invalid options for ${this.stringFormat.formatQualifiedName(descriptor, true)}. If you set (ts.client) = NO_CLIENT, you cannot set additional client styles.`);
            err.name = `PluginMessageError`;
            throw err;
        }
        // clients disabled altogether?
        if (this.params.force_client_none) {
            return [];
        }
        // look for service options
        if (opt.length) {
            return opt
                .filter(s => s !== ClientStyle.NO_CLIENT)
                .filter((value, index, array) => array.indexOf(value) === index);
        }
        // fall back to normal style set by option
        if (this.params.client_none)
            return [];
        else if (this.params.client_grpc1)
            return [ClientStyle.GRPC1_CLIENT];
        else
            return [ClientStyle.GENERIC_CLIENT];
    }
    getServerStyles(descriptor) {
        const opt = this.interpreter.readOurServiceOptions(descriptor)["ts.server"];
        // always check service options valid
        if (opt.includes(ServerStyle.NO_SERVER) && opt.some(s => s !== ServerStyle.NO_SERVER)) {
            let err = new Error(`You provided invalid options for ${this.stringFormat.formatQualifiedName(descriptor, true)}. If you set (ts.server) = NO_SERVER, you cannot set additional server styles.`);
            err.name = `PluginMessageError`;
            throw err;
        }
        // clients disabled altogether?
        if (this.params.force_server_none) {
            return [];
        }
        // look for service options
        if (opt.length) {
            return opt
                .filter(s => s !== ServerStyle.NO_SERVER)
                .filter((value, index, array) => array.indexOf(value) === index);
        }
        // fall back to normal style set by parameter
        if (this.params.server_generic) {
            return [ServerStyle.GENERIC_SERVER];
        }
        if (this.params.server_grpc1) {
            return [ServerStyle.GRPC1_SERVER];
        }
        return [];
    }
}
exports.OptionResolver = OptionResolver;
